from django.core.management.base import BaseCommand
from django.db.models.fields import BigAutoField, CharField, DateField, DateTimeField, BooleanField
from django.db.models.fields.related import ManyToManyField, ForeignKey
from django.db.models.fields.reverse_related import ManyToOneRel, ManyToManyRel

from devolving_music.models.artist import Artist
from devolving_music.models.song import Song
from devolving_music.models.event import Event
from devolving_music.models.song_submission import SongSubmission
from devolving_music.models.song_comparison import SongComparison
from devolving_music.views import MODEL_ENDPOINTS


MODELS_TO_TRANSPILE = [
    Artist,
    Song,
    Event,
    SongSubmission,
    SongComparison,
]


TYPES_OUTFILE = "models.d"
CONVERTER_OUTFILE = "models"


def make_filepath(name):
    return f"src/{name}.ts"


HEADER = (
    "/* This file has been autogenerated.\n"
    "DO NOT manually edit it.\n"
    "Run `python manage.py transpile_models` to update it. */\n\n"
)


def get_model_definitions():
    model_definitions = ""

    for model in MODELS_TO_TRANSPILE:
        model_definitions += f"export type {model.__name__} = {{\n"

        for field in model._meta.get_fields():
            t = type(field)
            type_string = None

            if t is ManyToOneRel or t is ManyToManyRel:
                pass
            elif t is BigAutoField:
                type_string = "number"
            elif t is CharField:
                type_string = "string"
            elif t is DateField:
                type_string = "string"
            elif t is DateTimeField:
                type_string = "string"
            elif t is BooleanField:
                type_string = "boolean"
            elif t is ForeignKey:
                type_string = field.related_model.__name__
            elif t is ManyToManyField:
                type_string = field.related_model.__name__ + "[]"
            else:
                raise ValueError(f"Unknown field type: {t}")

            if type_string is not None:
                model_definitions += f"  {field.name}: {type_string},\n"

        model_definitions += "}\n\n"

    return model_definitions


def get_tables_type():
    tables_type = "type TABLES = {\n"

    for path, viewset in MODEL_ENDPOINTS.items():
        tables_type += f"  {repr(path)}: {viewset.queryset.model.__name__},\n"

    tables_type += "}\n\n"

    return tables_type


def get_converters_header():
    header = f'import{{\n'
    for model in MODELS_TO_TRANSPILE:
        header += f"  {model.__name__},\n"
    header += f'}} from "./{TYPES_OUTFILE}";\n\n'

    return header


def get_converters():
    converters = ""

    for model in MODELS_TO_TRANSPILE:
        arg = model.__name__.lower()
        converters += f"function convert{model.__name__}({arg}: {model.__name__}){{\n"
        converters += "  return {\n"

        for field in model._meta.get_fields():
            t = type(field)
            expression = f"{arg}.{field.name}"

            if t is ManyToOneRel or t is ManyToManyRel:
                expression = None
            elif t is BigAutoField or t is CharField or t is BooleanField:
                pass
            elif t is DateField:
                expression = f"new Date({expression})"
            elif t is DateTimeField:
                expression = f"new Date({expression})"
            elif t is ForeignKey:
                expression = f"convert{field.related_model.__name__}({expression})"
            elif t is ManyToManyField:
                expression = f"{expression}.map(convert{field.related_model.__name__})"
            else:
                raise ValueError(f"Unknown field type: {t}")

            if expression is not None:
                converters += f"    {field.name}: {expression},\n"

        converters += "  };\n}\n\n"

    return converters


class Command(BaseCommand):
    help = 'Transpiles Django models into a Typescript type definition file'

    def add_arguments(self, parser):
        pass

    def handle(self, *args, **options):
        with open(make_filepath(TYPES_OUTFILE), "w") as fh:
            fh.write(HEADER)
            fh.write(get_model_definitions())
            fh.write(get_tables_type())

        with open(make_filepath(CONVERTER_OUTFILE), "w") as fh:
            fh.write(HEADER)
            fh.write(get_converters_header())
            fh.write(get_converters())

